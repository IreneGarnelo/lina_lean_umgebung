{"name": "Lina in Lean", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lina in Lean-1.0-library.zip", "introData": {"name": "1", "problemIndex": -1, "objects": [{"type": "text", "content": "2"}]}, "worlds": [{"name": "3", "levels": [{"name": "4", "problemIndex": 2, "objects": [{"type": "lean", "content": "5", "hidden": true}, {"type": "text", "content": "6"}, {"type": "theorem", "text": "7", "lean": "theorem beispiel_exact (x : nat) (h : x = 2) : x=2 :=\n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 53, "textBefore": "-- Level name : \"exact\" Taktik\n\nimport data.nat.basic -- hide\n\n/-\n# Struktur in Lean\nDie Struktur von S\u00e4tzen mit Beweis in Lean ist wiefolgt:\n\n```\ntheorem Name (Voraussetzung 1) (Voraussetzung 2) : Folgerung :=\nbegin\n...\nend\n```\n\nDabei kann der Name beliebig gew\u00e4hlt werden, sollte aber m\u00f6glichst einen Einblick in\ndie Aussage des Satzes geben (in Lean hei\u00dft zum Beispiel der Satz zur Kommutativit\u00e4t\nder Addition `add_comm`). Die Anzahl an Voraussetzungen kann variieren, es wurden nur\nbeispielhaft zwei vorgegeben. Zwischen `begin` und `end` stehen dann die Beweisschritte.\n\n# \"sorry\" Keywort\n\nZu Beginn der Bearbeitung steht im Beweis immer sorry. Dies ist ein Keyword, was so viel\nbedeutet wie: \"Hier fehlt ein Teil des Beweises\". Du kannst dieses Keyword verwenden, wenn \nein Beweis \u00fcberpr\u00fcft werden soll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, \ndass der Beweis stimmt, aber mit dem warning \"uses sorry\" darauf hinweisen, dass noch etwas \nzu tun ist. L\u00f6sche als Erstes das sorry, um mit dem Beweis zu starten.\n\n# Beweisschritte\nIn Lean l\u00f6st man Beweise, indem man Taktiken verwendet, die Beweisschritte\nabbilden. Nach jedem Beweischritt muss man ein `,` einf\u00fcgen, um dem Program mitzuteilen,\ndass er den Schritt verarbeiten kann. In diesem Level werden wir die `exact` Taktik kennenlernen.\nDiese kann verwendet werden, wenn eine der Aussagen `h`, die man in dem Beweiszustand sieht mit dem\nBeweisziel \u00fcbereinstimmt. Dann schreibt man `exact h,`. Das bedeutet in etwa so viel wie: \"Die zu\nBeweisende Aussage ist exakt die Aussage h.\"\n\nEs gibt viele Taktiken in Lean, du kannst den Teil davon, den du f\u00fcr diese Lernumgebung\nbrauchst in der linken Spalte unter \"Tactics\" finden, wir werden diese aber Schritt f\u00fcr \nSchritt einf\u00fchren.\n\n# Erste Aufgabe\nWir m\u00f6chten nun diese Taktik verwenden, um folgenden Satz zu zeigen: <br>\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x=2$. <br>\nLies als erstes die Formulierung in Lean und versuche den Satz dort wiederzuerkennen.\nNutze dann die `exact` Taktik um den Beweis zu l\u00f6sen.\n-/\n\n/- Theorem\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x=2$.\n-/\ntheorem beispiel_exact (x : nat) (h : x = 2) : x=2 :=\nbegin\n", "proof": "exact h,", "proof_hint": "sorry", "textAfter": "\nend", "height": 1, "editorText": "sorry", "lineOffset": 52, "name": "beispiel_exact", "statement": "(x : nat) (h : x = 2) : x=2"}]}, {"name": "8", "problemIndex": 2, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "text", "content": "10"}, {"type": "theorem", "text": "11", "lean": "theorem beispiel_rw (x : nat) (h : x = 2) : x*2 = 2*2 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "-- Level name : \"rw\" Taktik\n\nimport data.nat.basic -- hide\n\n/-\nWir werden nun eine weitere Taktik namens \"rw\" (Abk\u00fcrzung f\u00fcr rewrite) kennenlernen. \nMit dieser Taktik kann man Aussagen auf das Beweisziel anwenden.\n\nWenn h eine Aussage ist (z.B. `h : a = b`), dann bewirkt `rw h,`, dass LEAN die Aussage \n`h` in das Beweisziel einsetzt. In diesem Fall w\u00fcrde Lean in dem Beweisziel jedes `a` mit \neinem `b` ersetzten. Man kann angeben, an welcher Stelle des Beweiszieles die Aussage\nangewandt werden soll, indem man `rw h x,` schreibt. Wenn nur eine Stelle m\u00f6glich ist,\ndann kann man das Argument weglassen.\n\nWir werden folgende Aussage zeigen: <br>\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$. <br>\nDazu muss man die gegebene Aussage $x=2$ einfach in das Beweisziel einsetzen. Probiere\ndas mit dem `rw` Befehl aus und vergesse nicht das Komma am Ende der Zeile.\n-/\n\n/- Theorem\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$.\n-/\ntheorem beispiel_rw (x : nat) (h : x = 2) : x*2 = 2*2 :=\nbegin\n", "proof": "rw h,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "beispiel_rw", "statement": "(x : nat) (h : x = 2) : x*2 = 2*2"}]}, {"name": "12", "problemIndex": 2, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "text", "content": "14"}, {"type": "theorem", "text": "15", "lean": "theorem beispiel_rw (x : nat) (h : x = 2) : x*2 = 2*2 :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 21, "textBefore": "-- Level name : \"rw\" von rechts nach links\n\nimport data.nat.basic -- hide\n\n/-\nWir haben im vorherigem Level gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl \n`rw [h]`, in dem Beweisziel jedes `a` durch ein `b` ersetzt. Aber wie kann man jedes `b`\ndurch ein `a` ersetzen? Dazu verwendet man den Befehl `rw \u2190 h,`. Der Pfeil steht sozusagen \ndaf\u00fcr, dass LEAN die Aussage `h` von rechts nach links lesen soll. Du kannst den Pfeil mit\n`\\ l` (backslash + klein L) schreiben.\n\nEs ist nun wieder die gleiche Lean Aufgabe wie im vorherigem Level gegeben. Du k\u00f6nntest\ndiese genauso l\u00f6sen wie zuvor, aber erkennst du auch einen weiteren Weg der `\u2190` verwendet?\n-/\n\n/- Theorem\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$.\n-/\ntheorem beispiel_rw (x : nat) (h : x = 2) : x*2 = 2*2 :=\nbegin\n", "proof": "rw \u2190 h,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Brauchst du Hilfe, um den zweiten Weg zu finden?\nStatt $x$ durch zwei zu ersetzen k\u00f6nnte man auch die zweier durch $x$ ersetzen.\n-/", "height": 1, "editorText": "sorry", "lineOffset": 20, "name": "beispiel_rw", "statement": "(x : nat) (h : x = 2) : x*2 = 2*2"}, {"type": "hint", "content": "16", "title": "17"}]}, {"name": "18", "problemIndex": 2, "objects": [{"type": "lean", "content": "19", "hidden": true}, {"type": "text", "content": "20"}, {"type": "theorem", "text": "21", "lean": "theorem rw_mul_one (x : nat) : x*1=x :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 21, "textBefore": "-- Level name : \"rw\" und gegebene S\u00e4tze\n\nimport data.nat.basic -- hide\n\n/-\nMan kann die Taktik `rw` auch in Verkn\u00fcpf\u00fcng mit bekannten S\u00e4tze verwenden. In\nLean ist viel der Mathematik mit der wir an der Uni arbeiten implementiert und kann\nin Beweisen verwendet werden. In der linken Spalte findest du unter \"Theorem statements\"\neiniger solche S\u00e4tze, die f\u00fcr diese Lernumgebung n\u00fctzlich sein k\u00f6nnten.\n\nEiner dieser S\u00e4tze ist `mul_one` und sagt aus, dass f\u00fcr eine nat\u00fcrliche Zahl\n$x$ gilt, dass `x*1=` ist. Wenn man also in einem Beweiszustand `x*1` hat, kann\nman das mit `rw mul_one,` vereinfachen. Probiere es in dieser Aufgabe aus.\n-/\n\n/- Theorem\nSei $x \\in \\mathbb{N}$. Dann ist $x \\cdot 1=x$.\n-/\ntheorem rw_mul_one (x : nat) : x*1=x :=\nbegin\n", "proof": "rw mul_one,", "proof_hint": "sorry", "textAfter": "\nend", "height": 1, "editorText": "sorry", "lineOffset": 20, "name": "rw_mul_one", "statement": "(x : nat) : x*1=x"}]}, {"name": "22", "problemIndex": 2, "objects": [{"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "theorem", "text": "25", "lean": "theorem zwei_voraus_1 (x y : nat)(h1: x=2)(h2 : y=3) : x+1=y :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 16, "textBefore": "-- Level name : Zwei Voraussetzungen - Teil 1\n\nimport data.nat.basic -- hide\n\n/-\nIn der folgenden Aufgabe gibt es zwei Voraussetzungen. Benutze beide\nzusammen mit `rw` um die Aufgabe zu l\u00f6sen.\n-/\n\n/- Theorem\nSeien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n-/\ntheorem zwei_voraus_1 (x y : nat)(h1: x=2)(h2 : y=3) : x+1=y :=\nbegin\n", "proof": "rw h1,\nrw h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 14, "name": "zwei_voraus_1", "statement": "(x y : nat)(h1: x=2)(h2 : y=3) : x+1=y"}]}, {"name": "26", "problemIndex": 2, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "text", "content": "28"}, {"type": "theorem", "text": "29", "lean": "theorem zwei_voraus_2 (x y : nat)(h: x=2 \u2227 y=3) : x+1=y :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 20, "textBefore": "-- Level name : Zwei Voraussetzungen - Teil 2\n\nimport data.nat.basic -- hide\n\n/-\nWir haben nun fast die gleiche Aufgabe wie zuvor. Der einzige Unterschied ist,\ndass die beiden Voraussetzungen des Satzes mit einem und-Operator zu einer\nVoraussetzung zusammengefasst wurden. In solchen F\u00e4llen muss man, wenn man\ndie Voraussetzung anwenden m\u00f6chte, spezifizieren welchen Teil davon man meint.\nWenn man die Aussage, die links vom und-Operator ist verwenden m\u00f6chte schreibt man\n`rw h.left,` und ansonsten `rw h.right,`.\n-/\n\n/- Theorem\nSeien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n-/\ntheorem zwei_voraus_2 (x y : nat)(h: x=2 \u2227 y=3) : x+1=y :=\nbegin\n", "proof": "rw h.left,\nrw h.right,", "proof_hint": "sorry", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 18, "name": "zwei_voraus_2", "statement": "(x y : nat)(h: x=2 \u2227 y=3) : x+1=y"}]}, {"name": "30", "problemIndex": 2, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "text", "content": "32"}, {"type": "theorem", "text": "33", "lean": "theorem zwei_voraus_2 (x y : nat)(h: x=2 \u2227 y=3) : x+1=y :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 24, "textBefore": "-- Level name : Zwei Voraussetzungen - Teil 3\n\nimport data.nat.basic -- hide\n\n/-\nWir haben die exakte Aufgabe wie zuvor, m\u00f6chten aber nun sehen, dass wir den\nbeiden Aussagen, die mit einem und-Operator\" verbunden wurden, Namen geben k\u00f6nnen\num diese wieder einzeln verweden zu k\u00f6nnen. Das lohnt sich insbesondere wenn man\nin einem Beweis die Teilaussagen \u00f6fter braucht. Dazu verwendet man `have` wiefolgt: <br>\n`have h1 := h.left`. Statt `h1` kann man einen beliebigen Namen w\u00e4hlen.\n\nF\u00fchre in der unteren Aufgabe die Aussagen `h1` und `h2` ein und benutze sie um den Beweis\nmit `rw` zu l\u00f6sen.\n-/\n\n/- Theorem\nSeien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n-/\ntheorem zwei_voraus_2 (x y : nat)(h: x=2 \u2227 y=3) : x+1=y :=\nbegin\n", "proof": "have h1 := h.left,\nhave h2 := h.right,\nrw h1,\nrw h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 20, "name": "zwei_voraus_2", "statement": "(x y : nat)(h: x=2 \u2227 y=3) : x+1=y"}]}, {"name": "34", "problemIndex": 2, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "text", "content": "36"}, {"type": "theorem", "text": "37", "lean": "theorem rw_at (x y : nat)(h1: x=2)(h2 : y=x+1) : y=3 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 27, "textBefore": "-- Level name : \"rw\" auf Aussagen im Beweiszustand anwenden\n\nimport data.nat.basic -- hide\n\n/-\nWir m\u00f6chten nun eine neue Eigenschaft der Taktik `rw` einf\u00fchren. Man kann `rw` auch auf\ngegebene Aussagen aus dem Beweiszustand anwenden statt auf das Beweisziel. Man gibt dazu\nmit `at NameAussage` an, auf welche Aussage `rw` angewandt werden soll.\n\nIn dieser Aufgabe starten wir mit folgendem Beweiszustand:\n```\nxy: \u2115\nh1: x = 2\nh2: y = x + 1\n\u22a2 y = 3\n```\nUm `h1`in `h2` einzusetzen k\u00f6nnen wir `rw h1 at h2,` schreiben. Das Beweisziel wird\ndadurch nicht ge\u00e4ndert, aber `h2` wird zu `h2 : y = 2 + 1`. Probiere es in der Aufgabe aus.\n-/\n\n/- Theorem\nSeien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=x+1$. Dann ist $y=3$.\n-/\ntheorem rw_at (x y : nat)(h1: x=2)(h2 : y=x+1) : y=3 :=\nbegin\n", "proof": "rw h1 at h2,\nexact h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 25, "name": "rw_at", "statement": "(x y : nat)(h1: x=2)(h2 : y=x+1) : y=3"}]}, {"name": "38", "problemIndex": 2, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "theorem", "text": "41", "lean": "theorem zwischenziele (a b c : nat) : (a + b) * c = b * c + a * c :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 40, "textBefore": "-- Level name : Zwischenziele setzen\n\nimport data.nat.basic -- hide\n\n/-\nManchmal ist es sinnvoll in Lean sich Aussagen als Zwischenziel zu\nsetzen die man innerhalb des Beweises zeigt um sie dann im restlichen\nBeweis zu verwenden. Das kann man mit der Taktik `have`, die wir bereits\nzum Aufteilen von und-Aussagen kennegelernt haben. \u00dcbergreifend kann man\nsagen, dass `have` neue Aussagen einf\u00fchrt, die man dann zu Beweisen hat.\nIm Fall der und-Aussagen ist der Beweis trivialerweise durch die und-Aussage\ngegeben.\n\nIn der untenstehenden Aufgabe m\u00f6chten wir zeigen, dass f\u00fcr nat\u00fcrliche\nZahlen $a,b,c$ gilt, dass $(a + b) \\cdot c = b \\cdot c + a \\cdot c$.\nStatt direkt mit diesem Ziel zu beginnen k\u00f6nnen wir uns als erstes\nvornehmen, das Kommutativgesetzt in der Variante, in der die Summanden\nvor dem Produkt stehen, zu zeigen. Dazu schreiben wir:\n```\n have h : (a + b) * c = a * c + b * c,\n  { \n  },\n```\nzwischen den Klammern kommt dann der Beweis f\u00fcr die Aussage `h`, die dann im\nweiterem Verlauf verwendet werden kann.\n-/\n\n/- Theorem\nSeien $a, b$ und $c \\in \\mathbb{N}$. Dann ist $(a + b) \\cdot c = b \\cdot c + a \\cdot c$.\n-/\ntheorem zwischenziele (a b c : nat) : (a + b) * c = b * c + a * c :=\nbegin\n", "proof": "  have h : (a + b) * c = a * c + b * c,\n  { rw mul_comm (a+b) c,\n    rw mul_add,\n    rw mul_comm a c,\n    rw mul_comm c b,\n  },\n  rw add_comm (b*c) (a*c),\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 32, "name": "zwischenziele", "statement": "(a b c : nat) : (a + b) * c = b * c + a * c"}]}, {"name": "42", "problemIndex": 2, "objects": [{"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "theorem", "text": "45", "lean": "theorem rw_to_lhs (a b c : \u2124) (h1 : a + b = 1) (h2 : b + c = 1) : a + 1 = 1 + c :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 38, "textBefore": "-- Level name : \"rw\" einschr\u00e4nken.\n\nimport data.int.basic -- hide\n\n/-\nIn Level 2 haben wir gesehen, dass man mit `rw h x,` spezifizieren kann, wo\ndie Aussage `h` angewandt werden soll. In einigen F\u00e4llen ist dieses `x` aber\nnicht eindeutig. In der folgende Aufgabe werden wir zeigen, dass f\u00fcr ganze\nZahlen $a,b$ und $c$ gilt, dass falls $a+b=1$ und $b+c=1$, dann $a+1=1+c$.\nDazu k\u00f6nnen wir die beiden Einser im Ziel mit den beiden Voraussetzungen \nsubstituieren. Wenn wir aber nun `rw \u2190 h2,` oder auch `rw \u2190 h2 1,` verwenden,\ndann ersetzt Lean beide Einser. Um diese Umformung auf die linke Seite der\nGleichung einzuschr\u00e4nken k\u00f6nne wir `conv` verwenden. `conv` \u00f6ffnet ein\nneues Scope, in dem man die Seite der Gleichung festlegen kann und dann\nUmformungen durchf\u00fchren kann.\n\nProbiere, diese Aufgabe mit\n```\nconv{\n  to_lhs,\n  rw \u2190 h2,\n},\n```\nzu starten. `lhs` steht f\u00fcr left hand side. Entsprechend gibt es f\u00fcr die\nrechte Seite `rhs`.\n-/\n\n/- Theorem\nSeien $a, b$ und $c \\in \\mathbb{Z}$, $a+b=1$ und $b+c=1$. Dann ist $a+1=1+c$.\n-/\ntheorem rw_to_lhs (a b c : \u2124) (h1 : a + b = 1) (h2 : b + c = 1) : a + 1 = 1 + c :=\nbegin\n", "proof": "  conv{\n    to_lhs,\n    rw \u2190 h2,\n  },\n  rw \u2190 h1,\n  rw add_assoc,", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 32, "name": "rw_to_lhs", "statement": "(a b c : \u2124) (h1 : a + b = 1) (h2 : b + c = 1) : a + 1 = 1 + c"}]}, {"name": "46", "problemIndex": 2, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "text", "content": "48"}, {"type": "theorem", "text": "49", "lean": "example (x y : nat) : x = 2*y \u2192 2*x = 4*y :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 30, "textBefore": "-- Level name : \"intro\" Taktik\n\nimport data.nat.basic -- hide\n\n\n/-\nFalls die Aussage, die zu zeigen ist eine Implikation enth\u00e4lt, wie das untere\nBeispiel, dann w\u00fcrde man bei einem Beweis auf Papier schreiben \"Seien $x$\nund $y$ sodass ...\" um konkrete Instanzen zu haben mit denen man rechnen kann.\nIn Lean tut man das mit `intro h,`.\n\nWenn man in der unteren Aufgabe `intro h,` anwendet, dann wird `h: x = 2 * y`\nzu einer im Beweiszustand gegebenen Aussage und das Beweisziel \u00e4ndert sich zur\nFolgerung aus der Implikation, also `2*x = 4*y`.\n\nDu kannst nun mit `rw` zusammen mit `h` und `mul_assoc` das Beweisziel zu\n`2 * 2 * y = 4 * y` umformen. Ein Ziel dieser Art, auf den auf beiden Seiten\nbis auf simple arithmetische Operationen das gleiche steht kannst du mit\n`refl,` l\u00f6sen.\n-/\n\n/- Theorem\nSeien $x$ und $y \\in \\mathbb{N}$, dann folgt aus $x=2 /cdot y$, dass $2 /cdot x = 4 /cdot y$.\n-/\nexample (x y : nat) : x = 2*y \u2192 2*x = 4*y :=\nbegin\n", "proof": "  intro h,\n  rw h,\n  rw \u2190 mul_assoc,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 26, "name": "", "statement": "(x y : nat) : x = 2*y \u2192 2*x = 4*y"}]}]}, {"name": "50", "levels": [{"name": "51", "problemIndex": 2, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "text", "content": "53"}, {"type": "theorem", "text": "54", "lean": "theorem eind_neutr {G : Type} [group G] (e1 e2 : G)\n  (h1 : \u2200 a : G, e1 * a = a \u2227 a * e1 = a)\n  (h2 : \u2200 a : G, e2 * a = a \u2227 a * e2 = a) :\n  e1 = e2 :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 32, "textBefore": "-- Level name : Eindeutigkeit des neutralen Elements\n\nimport algebra.group.basic -- hide\n\n/-\nWir werden uns nun mit Gruppen auseinandersetzen. Um in einem Satz\n$G$ als Gruppe zu definieren schreibt man zu Beginn der Voraussetzungen\n`{G : Type} [group G]`.\n\nWir werden zeigen, dass das neutrale Element einer Gruppe eindeutig ist.\nSchau dir zun\u00e4chste die Lean-Formulierung dieses Satzes an. Wieso ist sie\ngleichbedeutend damit, dass das neutrale Element eindeutig ist?\n\nMan kann nun die Annahme, dass ELement e1 neutral ist auf Element e2\nanwenden und umgekehrt. Verwende dazu `have h1_e2 := h1 e2,` und\n`have h2_e1 := h2 e1,`. Kannst du die beiden Aussagen verwenden um das\nBeweisziel zu l\u00f6sen? In Level 6 aus den Tutorials kannst du nachschlafen,\nwie du mit und-Aussagen umgehen kannst.\n-/\n\n/- Theorem\nDas neutrale Element einer Gruppe ist eindeutig.\n-/\ntheorem eind_neutr {G : Type} [group G] (e1 e2 : G)\n  (h1 : \u2200 a : G, e1 * a = a \u2227 a * e1 = a)\n  (h2 : \u2200 a : G, e2 * a = a \u2227 a * e2 = a) :\n  e1 = e2 :=\nbegin\n", "proof": "  have h1_e2 := h1 e2,\n  have h2_e1 := h2 e1,\n  rw \u2190 h1_e2.left,\n  rw h2_e1.right,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 28, "name": "eind_neutr", "statement": "{G : Type} [group G] (e1 e2 : G)\n  (h1 : \u2200 a : G, e1 * a = a \u2227 a * e1 = a)\n  (h2 : \u2200 a : G, e2 * a = a \u2227 a * e2 = a) :\n  e1 = e2"}]}, {"name": "55", "problemIndex": 2, "objects": [{"type": "lean", "content": "56", "hidden": true}, {"type": "text", "content": "57"}, {"type": "theorem", "text": "58", "lean": "theorem eind_mul {G : Type} [group G] (x y z : G) :\n  x * y = x * z \u2192 y = z :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 34, "textBefore": "-- Level name : Falls $x \\cdot y = x \\cdot z$, dann ist $y=z$\n\nimport algebra.group.basic -- hide\n\n/-\nAls n\u00e4chstes werden wir uns einen l\u00e4ngeren Beweis anschauen. Da dieser\naus vielen Schritten besteht ist er vorgegeben, damit du ihn zusammen mit\ndem Lean Output nachvollziehen kannst. Der Beweis funktioniert wiefolgt:\n```\nintro h,\n  have h_inv : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * (x * z),\n  { rw h, },\n  rw [\u2190mul_assoc, \u2190mul_assoc] at h_inv,\n  rw mul_left_inv x at h_inv,\n  repeat{ rw one_mul at h_inv, },\n  exact h_inv,\n```\nKannst du in Worten beschreiben was in jedem Schritt passiert? In dem Beweis kommt\ndie neue Taktik `repeat` vor. Kannst du aus dem Kontext erahnen was sie tut?\n-/\n\n/- Theorem\nDie Gruppenverkn\u00fcpfung ist eindeutig.\n-/\ntheorem eind_mul {G : Type} [group G] (x y z : G) :\n  x * y = x * z \u2192 y = z :=\nbegin\n", "proof": "  intro h,\n  have h_inv : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * (x * z),\n  { rw h, },\n  rw [\u2190mul_assoc, \u2190mul_assoc] at h_inv,\n  rw mul_left_inv x at h_inv,\n  repeat{ rw one_mul at h_inv, },\n  exact h_inv,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 27, "name": "eind_mul", "statement": "{G : Type} [group G] (x y z : G) :\n  x * y = x * z \u2192 y = z"}]}, {"name": "59", "problemIndex": -1, "objects": [{"type": "lean", "content": "60", "hidden": true}, {"type": "text", "content": "61"}, {"type": "lean", "content": "62", "hidden": false}]}, {"name": "63", "problemIndex": -1, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "text", "content": "65"}, {"type": "lean", "content": "66", "hidden": false}]}, {"name": "67", "problemIndex": -1, "objects": [{"type": "lean", "content": "68", "hidden": true}, {"type": "lean", "content": "69", "hidden": false}]}, {"name": "70", "problemIndex": -1, "objects": [{"type": "lean", "content": "71", "hidden": false}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": false}, {"type": "hint", "content": "74", "title": "75"}, {"type": "lean", "content": "76", "hidden": false}]}], "parents": [0]}, {"name": "77", "levels": [{"name": "78", "problemIndex": -1, "objects": [{"type": "lean", "content": "79", "hidden": true}, {"type": "text", "content": "80"}, {"type": "hint", "content": "81", "title": "82"}, {"type": "lean", "content": "83", "hidden": false}]}, {"name": "84", "problemIndex": -1, "objects": [{"type": "lean", "content": "85", "hidden": true}, {"type": "text", "content": "86"}, {"type": "lean", "content": "87", "hidden": false}]}, {"name": "88", "problemIndex": -1, "objects": [{"type": "lean", "content": "89", "hidden": true}, {"type": "text", "content": "90"}, {"type": "lean", "content": "91", "hidden": false}]}, {"name": "92", "problemIndex": -1, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "lean", "content": "97", "hidden": false}]}, {"name": "98", "problemIndex": -1, "objects": [{"type": "lean", "content": "99", "hidden": true}, {"type": "lean", "content": "100", "hidden": false}]}], "parents": [1]}], "texts": [["Lina in Lean", "intro", "# Lineare Algebra mit Lean\n## Worum geht es in diesem Spiel?\n### Mathematisch \nIn diesem Spiel werden wir Gruppen und K\u00f6rper und einige deren Eigenschaften einf\u00fchren\nund beweisen. Vor diesen Themen ist ein Kapitel mit Aufgaben, dass als Tutorial dient.\n\n### Technisch\nWir werden die Programmiersprache \n<a href=\"https://leanprover-community.github.io/\" target=\"blank\">LEAN</a> kennenlernen.\nLEAN ist ein interaktiver Theorembeweiser. In einem Theorembeweiser kann man\neinen Beweis Schritt f\u00fcr Schritt (in Computersprache) eingeben. Dieser \u00fcberpr\u00fcft\ndann, ob der Beweis korrekt ist und kann an jeder Stelle des Beweises Feedback zum\naktuellen Stand des Beweises geben.\n\n\n## Eine kurze Anleitung.\nMit diesem Tool kannst du an dieser Einheit arbeiten. Die Einheit ist in die Kapitel\nTutorial, Gruppen und K\u00f6rper eingeteilt. Jedes Kapitel hat \nmehrere Level. Am besten ist es, wenn du die Kapitel und Level der Reihe nach \nbearbeitest.\n\nIn jedem Level gibt es als Erstes einen Text, der den mathematischen Inhalt und die \nn\u00f6tigen LEAN-Anleitungen des Levels einf\u00fchrt. Darunter ist die zu l\u00f6sende Aufgabe:\nder Beweis eines Satzes, der in LEAN ausgef\u00fchrt werden soll.\n\nDein Fortschritt wird im Normalfall automatisch im Browser gespeichert. Wenn du \nvorsichtshalber deinen Stand speichern m\u00f6chtest klicke in diesem Fensters den \ud83d\udcbe Button \n\u00fcber dem Spielbaum. Damit wird dein Spielstand in einer json-Datei gespeichert. Diese \nkannst du beim n\u00e4chsten Mal hochladen, indem du den \ud83d\udcdd Button klickst. \n\nViel Spa\u00df beim Coden!\n\n## Du bist mit dem Tool fertig - was nun?\n\nWir haben ein weiteres Spiel zu den nat\u00fcrlichen Zahlen entwickelt. Du kannst es \n<a href=\"https://ireneupb.github.io/lean_umgebung/\" target=\"blank\">hier</a> spielen.\n", "Tutorial", "\"exact\" Taktik", "import data.nat.basic -- hide\n", "# Struktur in Lean\nDie Struktur von S\u00e4tzen mit Beweis in Lean ist wiefolgt:\n\n```\ntheorem Name (Voraussetzung 1) (Voraussetzung 2) : Folgerung :=\nbegin\n...\nend\n```\n\nDabei kann der Name beliebig gew\u00e4hlt werden, sollte aber m\u00f6glichst einen Einblick in\ndie Aussage des Satzes geben (in Lean hei\u00dft zum Beispiel der Satz zur Kommutativit\u00e4t\nder Addition `add_comm`). Die Anzahl an Voraussetzungen kann variieren, es wurden nur\nbeispielhaft zwei vorgegeben. Zwischen `begin` und `end` stehen dann die Beweisschritte.\n\n# \"sorry\" Keywort\n\nZu Beginn der Bearbeitung steht im Beweis immer sorry. Dies ist ein Keyword, was so viel\nbedeutet wie: \"Hier fehlt ein Teil des Beweises\". Du kannst dieses Keyword verwenden, wenn \nein Beweis \u00fcberpr\u00fcft werden soll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, \ndass der Beweis stimmt, aber mit dem warning \"uses sorry\" darauf hinweisen, dass noch etwas \nzu tun ist. L\u00f6sche als Erstes das sorry, um mit dem Beweis zu starten.\n\n# Beweisschritte\nIn Lean l\u00f6st man Beweise, indem man Taktiken verwendet, die Beweisschritte\nabbilden. Nach jedem Beweischritt muss man ein `,` einf\u00fcgen, um dem Program mitzuteilen,\ndass er den Schritt verarbeiten kann. In diesem Level werden wir die `exact` Taktik kennenlernen.\nDiese kann verwendet werden, wenn eine der Aussagen `h`, die man in dem Beweiszustand sieht mit dem\nBeweisziel \u00fcbereinstimmt. Dann schreibt man `exact h,`. Das bedeutet in etwa so viel wie: \"Die zu\nBeweisende Aussage ist exakt die Aussage h.\"\n\nEs gibt viele Taktiken in Lean, du kannst den Teil davon, den du f\u00fcr diese Lernumgebung\nbrauchst in der linken Spalte unter \"Tactics\" finden, wir werden diese aber Schritt f\u00fcr \nSchritt einf\u00fchren.\n\n# Erste Aufgabe\nWir m\u00f6chten nun diese Taktik verwenden, um folgenden Satz zu zeigen: <br>\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x=2$. <br>\nLies als erstes die Formulierung in Lean und versuche den Satz dort wiederzuerkennen.\nNutze dann die `exact` Taktik um den Beweis zu l\u00f6sen.\n", "Sei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x=2$.\n", "\"rw\" Taktik", "import data.nat.basic -- hide\n", "Wir werden nun eine weitere Taktik namens \"rw\" (Abk\u00fcrzung f\u00fcr rewrite) kennenlernen. \nMit dieser Taktik kann man Aussagen auf das Beweisziel anwenden.\n\nWenn h eine Aussage ist (z.B. `h : a = b`), dann bewirkt `rw h,`, dass LEAN die Aussage \n`h` in das Beweisziel einsetzt. In diesem Fall w\u00fcrde Lean in dem Beweisziel jedes `a` mit \neinem `b` ersetzten. Man kann angeben, an welcher Stelle des Beweiszieles die Aussage\nangewandt werden soll, indem man `rw h x,` schreibt. Wenn nur eine Stelle m\u00f6glich ist,\ndann kann man das Argument weglassen.\n\nWir werden folgende Aussage zeigen: <br>\nSei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$. <br>\nDazu muss man die gegebene Aussage $x=2$ einfach in das Beweisziel einsetzen. Probiere\ndas mit dem `rw` Befehl aus und vergesse nicht das Komma am Ende der Zeile.\n", "Sei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$.\n", "\"rw\" von rechts nach links", "import data.nat.basic -- hide\n", "Wir haben im vorherigem Level gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl \n`rw [h]`, in dem Beweisziel jedes `a` durch ein `b` ersetzt. Aber wie kann man jedes `b`\ndurch ein `a` ersetzen? Dazu verwendet man den Befehl `rw \u2190 h,`. Der Pfeil steht sozusagen \ndaf\u00fcr, dass LEAN die Aussage `h` von rechts nach links lesen soll. Du kannst den Pfeil mit\n`\\ l` (backslash + klein L) schreiben.\n\nEs ist nun wieder die gleiche Lean Aufgabe wie im vorherigem Level gegeben. Du k\u00f6nntest\ndiese genauso l\u00f6sen wie zuvor, aber erkennst du auch einen weiteren Weg der `\u2190` verwendet?\n", "Sei $x \\in \\mathbb{N}$ und $x=2$. Dann ist $x \\cdot 2=2 \\cdot 2$.\n", "Statt $x$ durch zwei zu ersetzen k\u00f6nnte man auch die zweier durch $x$ ersetzen.\n", "Brauchst du Hilfe, um den zweiten Weg zu finden?", "\"rw\" und gegebene S\u00e4tze", "import data.nat.basic -- hide\n", "Man kann die Taktik `rw` auch in Verkn\u00fcpf\u00fcng mit bekannten S\u00e4tze verwenden. In\nLean ist viel der Mathematik mit der wir an der Uni arbeiten implementiert und kann\nin Beweisen verwendet werden. In der linken Spalte findest du unter \"Theorem statements\"\neiniger solche S\u00e4tze, die f\u00fcr diese Lernumgebung n\u00fctzlich sein k\u00f6nnten.\n\nEiner dieser S\u00e4tze ist `mul_one` und sagt aus, dass f\u00fcr eine nat\u00fcrliche Zahl\n$x$ gilt, dass `x*1=` ist. Wenn man also in einem Beweiszustand `x*1` hat, kann\nman das mit `rw mul_one,` vereinfachen. Probiere es in dieser Aufgabe aus.\n", "Sei $x \\in \\mathbb{N}$. Dann ist $x \\cdot 1=x$.\n", "Zwei Voraussetzungen - Teil 1", "import data.nat.basic -- hide\n", "In der folgenden Aufgabe gibt es zwei Voraussetzungen. Benutze beide\nzusammen mit `rw` um die Aufgabe zu l\u00f6sen.\n", "Seien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n", "Zwei Voraussetzungen - Teil 2", "import data.nat.basic -- hide\n", "Wir haben nun fast die gleiche Aufgabe wie zuvor. Der einzige Unterschied ist,\ndass die beiden Voraussetzungen des Satzes mit einem und-Operator zu einer\nVoraussetzung zusammengefasst wurden. In solchen F\u00e4llen muss man, wenn man\ndie Voraussetzung anwenden m\u00f6chte, spezifizieren welchen Teil davon man meint.\nWenn man die Aussage, die links vom und-Operator ist verwenden m\u00f6chte schreibt man\n`rw h.left,` und ansonsten `rw h.right,`.\n", "Seien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n", "Zwei Voraussetzungen - Teil 3", "import data.nat.basic -- hide\n", "Wir haben die exakte Aufgabe wie zuvor, m\u00f6chten aber nun sehen, dass wir den\nbeiden Aussagen, die mit einem und-Operator\" verbunden wurden, Namen geben k\u00f6nnen\num diese wieder einzeln verweden zu k\u00f6nnen. Das lohnt sich insbesondere wenn man\nin einem Beweis die Teilaussagen \u00f6fter braucht. Dazu verwendet man `have` wiefolgt: <br>\n`have h1 := h.left`. Statt `h1` kann man einen beliebigen Namen w\u00e4hlen.\n\nF\u00fchre in der unteren Aufgabe die Aussagen `h1` und `h2` ein und benutze sie um den Beweis\nmit `rw` zu l\u00f6sen.\n", "Seien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=3$. Dann ist $x + 1= y$.\n", "\"rw\" auf Aussagen im Beweiszustand anwenden", "import data.nat.basic -- hide\n", "Wir m\u00f6chten nun eine neue Eigenschaft der Taktik `rw` einf\u00fchren. Man kann `rw` auch auf\ngegebene Aussagen aus dem Beweiszustand anwenden statt auf das Beweisziel. Man gibt dazu\nmit `at NameAussage` an, auf welche Aussage `rw` angewandt werden soll.\n\nIn dieser Aufgabe starten wir mit folgendem Beweiszustand:\n```\nxy: \u2115\nh1: x = 2\nh2: y = x + 1\n\u22a2 y = 3\n```\nUm `h1`in `h2` einzusetzen k\u00f6nnen wir `rw h1 at h2,` schreiben. Das Beweisziel wird\ndadurch nicht ge\u00e4ndert, aber `h2` wird zu `h2 : y = 2 + 1`. Probiere es in der Aufgabe aus.\n", "Seien $x$ und $y \\in \\mathbb{N}$ mit $x=2$ und $y=x+1$. Dann ist $y=3$.\n", "Zwischenziele setzen", "import data.nat.basic -- hide\n", "Manchmal ist es sinnvoll in Lean sich Aussagen als Zwischenziel zu\nsetzen die man innerhalb des Beweises zeigt um sie dann im restlichen\nBeweis zu verwenden. Das kann man mit der Taktik `have`, die wir bereits\nzum Aufteilen von und-Aussagen kennegelernt haben. \u00dcbergreifend kann man\nsagen, dass `have` neue Aussagen einf\u00fchrt, die man dann zu Beweisen hat.\nIm Fall der und-Aussagen ist der Beweis trivialerweise durch die und-Aussage\ngegeben.\n\nIn der untenstehenden Aufgabe m\u00f6chten wir zeigen, dass f\u00fcr nat\u00fcrliche\nZahlen $a,b,c$ gilt, dass $(a + b) \\cdot c = b \\cdot c + a \\cdot c$.\nStatt direkt mit diesem Ziel zu beginnen k\u00f6nnen wir uns als erstes\nvornehmen, das Kommutativgesetzt in der Variante, in der die Summanden\nvor dem Produkt stehen, zu zeigen. Dazu schreiben wir:\n```\n have h : (a + b) * c = a * c + b * c,\n  { \n  },\n```\nzwischen den Klammern kommt dann der Beweis f\u00fcr die Aussage `h`, die dann im\nweiterem Verlauf verwendet werden kann.\n", "Seien $a, b$ und $c \\in \\mathbb{N}$. Dann ist $(a + b) \\cdot c = b \\cdot c + a \\cdot c$.\n", "\"rw\" einschr\u00e4nken.", "import data.int.basic -- hide\n", "In Level 2 haben wir gesehen, dass man mit `rw h x,` spezifizieren kann, wo\ndie Aussage `h` angewandt werden soll. In einigen F\u00e4llen ist dieses `x` aber\nnicht eindeutig. In der folgende Aufgabe werden wir zeigen, dass f\u00fcr ganze\nZahlen $a,b$ und $c$ gilt, dass falls $a+b=1$ und $b+c=1$, dann $a+1=1+c$.\nDazu k\u00f6nnen wir die beiden Einser im Ziel mit den beiden Voraussetzungen \nsubstituieren. Wenn wir aber nun `rw \u2190 h2,` oder auch `rw \u2190 h2 1,` verwenden,\ndann ersetzt Lean beide Einser. Um diese Umformung auf die linke Seite der\nGleichung einzuschr\u00e4nken k\u00f6nne wir `conv` verwenden. `conv` \u00f6ffnet ein\nneues Scope, in dem man die Seite der Gleichung festlegen kann und dann\nUmformungen durchf\u00fchren kann.\n\nProbiere, diese Aufgabe mit\n```\nconv{\n  to_lhs,\n  rw \u2190 h2,\n},\n```\nzu starten. `lhs` steht f\u00fcr left hand side. Entsprechend gibt es f\u00fcr die\nrechte Seite `rhs`.\n", "Seien $a, b$ und $c \\in \\mathbb{Z}$, $a+b=1$ und $b+c=1$. Dann ist $a+1=1+c$.\n", "\"intro\" Taktik", "import data.nat.basic -- hide\n", "Falls die Aussage, die zu zeigen ist eine Implikation enth\u00e4lt, wie das untere\nBeispiel, dann w\u00fcrde man bei einem Beweis auf Papier schreiben \"Seien $x$\nund $y$ sodass ...\" um konkrete Instanzen zu haben mit denen man rechnen kann.\nIn Lean tut man das mit `intro h,`.\n\nWenn man in der unteren Aufgabe `intro h,` anwendet, dann wird `h: x = 2 * y`\nzu einer im Beweiszustand gegebenen Aussage und das Beweisziel \u00e4ndert sich zur\nFolgerung aus der Implikation, also `2*x = 4*y`.\n\nDu kannst nun mit `rw` zusammen mit `h` und `mul_assoc` das Beweisziel zu\n`2 * 2 * y = 4 * y` umformen. Ein Ziel dieser Art, auf den auf beiden Seiten\nbis auf simple arithmetische Operationen das gleiche steht kannst du mit\n`refl,` l\u00f6sen.\n", "Seien $x$ und $y \\in \\mathbb{N}$, dann folgt aus $x=2 /cdot y$, dass $2 /cdot x = 4 /cdot y$.\n", "Gruppen", "Eindeutigkeit des neutralen Elements", "import algebra.group.basic -- hide\n", "Wir werden uns nun mit Gruppen auseinandersetzen. Um in einem Satz\n$G$ als Gruppe zu definieren schreibt man zu Beginn der Voraussetzungen\n`{G : Type} [group G]`.\n\nWir werden zeigen, dass das neutrale Element einer Gruppe eindeutig ist.\nSchau dir zun\u00e4chste die Lean-Formulierung dieses Satzes an. Wieso ist sie\ngleichbedeutend damit, dass das neutrale Element eindeutig ist?\n\nMan kann nun die Annahme, dass ELement e1 neutral ist auf Element e2\nanwenden und umgekehrt. Verwende dazu `have h1_e2 := h1 e2,` und\n`have h2_e1 := h2 e1,`. Kannst du die beiden Aussagen verwenden um das\nBeweisziel zu l\u00f6sen? In Level 6 aus den Tutorials kannst du nachschlafen,\nwie du mit und-Aussagen umgehen kannst.\n", "Das neutrale Element einer Gruppe ist eindeutig.\n", "Falls $x \\cdot y = x \\cdot z$, dann ist $y=z$", "import algebra.group.basic -- hide\n", "Als n\u00e4chstes werden wir uns einen l\u00e4ngeren Beweis anschauen. Da dieser\naus vielen Schritten besteht ist er vorgegeben, damit du ihn zusammen mit\ndem Lean Output nachvollziehen kannst. Der Beweis funktioniert wiefolgt:\n```\nintro h,\n  have h_inv : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * (x * z),\n  { rw h, },\n  rw [\u2190mul_assoc, \u2190mul_assoc] at h_inv,\n  rw mul_left_inv x at h_inv,\n  repeat{ rw one_mul at h_inv, },\n  exact h_inv,\n```\nKannst du in Worten beschreiben was in jedem Schritt passiert? In dem Beweis kommt\ndie neue Taktik `repeat` vor. Kannst du aus dem Kontext erahnen was sie tut?\n", "Die Gruppenverkn\u00fcpfung ist eindeutig.\n", "Eindeutigkeit des Inversen Elements", "import algebra.group.basic -- hide\n", "Nun werden wir auch die Eindeutigkeit des Inversen Elements zeigen.\nVergleiche die Formulierung des Satzes zum vorherigem, welche\nGemeinsamkeiten siehts du?\n\nDu kannst wiefolgt umgehen: Schreibe mithilfe von `mul_one` und `one_mul`\n(die Bedeutung davon kannst du unter Theorem Statements finden) das Beweisziel um,\nsodass du `b*1=1*c` hast. Ersetze nun die beiden Einer durch das Produkt\nvon a mit jeweils den nach Voraussetzung gegebenen Inversen b und c. W\u00e4hle\ndabei jeweils wie du jede Eins ersetzt so, dass du zum Schluss das Beweisziel durch\nanwenden von Assoziativit\u00e4t (`mul_assoc`) l\u00f6sen kannst.\n", "-- Theorem: Das Inverse eines Elements ist Eindeutig.\ntheorem eind_inv {G : Type} [group G] (a b c : G)\n  (hb : b * a = 1 \u2227 a * b = 1) (hc : c * a = 1 \u2227 a * c = 1) :\n  b = c :=\nbegin\n  rw \u2190 mul_one b,\n  rw \u2190 one_mul c,\n  conv {\n    to_lhs, \n    rw \u2190 hc.right,\n  },\n  rw \u2190 hb.1,\n  rw mul_assoc,\nend\n", "Falls jedes Element Selbstinvers ist, ist G abelsch", "import algebra.group.basic -- hide\n", "In deisem Level werden wir zeigen, das wenn jedes Element einer Gruppe $G$ selbstinvers ist,\n$G$ abelsch ist.\n\nBeginne mit `intros h,` um das Beweisziel von der allgemeinen Abelheit der Gruppe auf die\nAussage $a /cdot b = b /cdot a$ zu bringen.\n\nDas die Verkn\u00fcpfung zweier Elemente $a /cdot b$ auch wieder ein Element der Gruppe ist,\ngilt auch f\u00fcr dieses, dass es selbstinvers ist. F\u00fchre die Aussage `h1 : (a * b)\u207b\u00b9 = a * b`\nein und Beweise sie. (Falls du nachschlagen m\u00f6chtest, wie du mit Zwischenzielen\numgehst, schaue in Level 9 des Tutorials rein).\n\nZus\u00e4tzlich gilt aber f\u00fcr das Inverse einer Verkn\u00fcpfung auch die allgemeine Eigenschaft:\n$(a \\cdot b)^{-1}=b^{-1} \\cdot a^{-1}$. F\u00fchre auch dies als Aussage `h2` ein. Diese Aussage\nist in Lean implementiert als `mul_inv_rev`, du kannst diesen Satz also zusammen mit `rw`\nanwenden.\n\nNun kannst du h1 in h2 einsetzen. Ersetze zulezt in `h2`: `a\u207b\u00b9` durch `a` und `b\u207b\u00b9` durch `b`,\nindem du `h` anwendest.\n", "-- Theorem: Falls $g /cdot g = 1$ f\u00fcr alle $g \\in G$, dann ist $G$ abelsch.\ntheorem selbstinv_abelsch {G : Type} [group G]\n  (h : \u2200 a : G, a\u207b\u00b9 = a) :\n  \u2200 a b : G, a * b = b * a :=\nbegin\n  intros a b,\n  have h1 : (a * b)\u207b\u00b9 = a * b,\n  { rw h, },\n  have h2 : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9,\n  { rw mul_inv_rev a b, },\n  rw h1 at h2,\n  rw h a at h2,\n  rw h b at h2,\n  exact h2,\nend", "Falls Inverse kommutieren, dann ist $G$ abelsch", "import algebra.group.basic -- hide\n", "/- Wir werden uns nun folgendes Lemma anschauen, welches wir in der letzten Aufgabe\nanwenden werden. Du musst diesen Beweis nicht selber f\u00fchren, sondern kannst ihr\neinfach mithilfe der Lean-Ausgabe nachvollziehen:\n```\nintros x y,\n  specialize h x y,\n  have h1 : (x\u207b\u00b9 * y\u207b\u00b9)\u207b\u00b9 = (y\u207b\u00b9 * x\u207b\u00b9)\u207b\u00b9, from congr_arg has_inv.inv h,\n  rw mul_inv_rev x\u207b\u00b9 y\u207b\u00b9 at h1,\n  rw mul_inv_rev y\u207b\u00b9 x\u207b\u00b9 at h1,\n  repeat {rw inv_inv at h1,},\n  exact h1.symm,\n```\nDu musst nicht alle Keyw\u00f6rter wie `specialize` und `congr_arg` kennen. Kannst du trotzdem f\u00fcr jeden\nSchritt beschreiben was passiert?\n -/\n-- Theorem: Falls $x^{-1} \\cdot y^{-1} = y^{-1} \\cdot x^{-1}$ f\u00fcr alle $x,y \\in G$, dann ist $G$ abelsch.\ntheorem inv_abelsch {G : Type} [group G]\n  (h : \u2200 x y : G, x\u207b\u00b9 * y\u207b\u00b9 = y\u207b\u00b9 * x\u207b\u00b9) :\n  \u2200 x y : G, x * y = y * x :=\nbegin\n  intros x y,\n  -- Start with the given condition for x\u207b\u00b9 and y\u207b\u00b9\n  specialize h x y,\n  -- Take the inverse of both sides\n  have h1 : (x\u207b\u00b9 * y\u207b\u00b9)\u207b\u00b9 = (y\u207b\u00b9 * x\u207b\u00b9)\u207b\u00b9, from congr_arg has_inv.inv h,\n  -- Use the property (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9 on both sides\n  rw mul_inv_rev x\u207b\u00b9 y\u207b\u00b9 at h1,\n  rw mul_inv_rev y\u207b\u00b9 x\u207b\u00b9 at h1,\n  repeat {rw inv_inv at h1,},\n  exact h1.symm,\nend\n", "Falls $y^{-1} \\cdot x^{-1} \\cdot y \\cdot x = 1$, dann ist $G$ abelsch", "import algebra.group.basic\n", "import game.Gruppen.level_5 --hide\n", "/- Zuletzt m\u00f6chten wir f\u00fcr Gruppen zeigen, dass falls $y^{-1} \\cdot x^{-1} \\cdot y \\cdot x = 1$ f\u00fcr\nalle $x,y \\in G$ gilt, die Gruppe abelsch ist. Gehe dazu wiefolgt vor:\nZeige zun\u00e4chst, dass die Voraussetzungen des Lemmas in Level 5 erf\u00fcllt sind. F\u00fchre dazu\nein Zwischenziel ein (f\u00fcr diesen Teil kannst du `eq_inv_of_mul_eq_one` und `mul_inv_rev` verwenden).\nDann kannst du mit `apply inv_abelsch,` das Resultat aus Level 5 anwenden. Wie kannst du nun den Beweis \nschlie\u00dfen?\n -/\n", "Du kannst folgende Beweisstuktur verwenden und die sorry durch Beweisschritte austauschen:\n```\n{intros x y,\nspecialize h x y,\nrw mul_assoc at h,\nhave h2 : y\u207b\u00b9 * x\u207b\u00b9 = (y * x)\u207b\u00b9,\n{ sorry, },\nhave h3 : (y * x)\u207b\u00b9 = x\u207b\u00b9 * y\u207b\u00b9,\n{ sorry, },\nsorry,},\n```\n", "Brauchst du Hilfe, das Zwischenergebnis zu beweisen?", "-- Theorem: Falls $y^{-1} \\cdot x^{-1} \\cdot y \\cdot x$ f\u00fcr alle $x, y \\in G$, dann ist $G$ abelsch.\ntheorem inv_inv_abelsch {G : Type} [group G]\n  (h : \u2200 x y : G, y\u207b\u00b9 * x\u207b\u00b9 * y * x = 1) :\n  \u2200 x y : G, x * y = y * x :=\nbegin\n  have h1 : \u2200 x y : G, x\u207b\u00b9 * y\u207b\u00b9 = y\u207b\u00b9 * x\u207b\u00b9,\n  {intros x y,\n  -- From the hypothesis, specialize h to x and y\n  specialize h x y,\n  -- Regroup the terms in the hypothesis using associativity\n  rw mul_assoc at h, -- y\u207b\u00b9 * x\u207b\u00b9 * (y * x) = 1\n  -- Use the hypothesis to deduce that y\u207b\u00b9 * x\u207b\u00b9 is the inverse of y * x\n  have h2 : y\u207b\u00b9 * x\u207b\u00b9 = (y * x)\u207b\u00b9,\n  { exact eq_inv_of_mul_eq_one h, },\n  -- The inverse of y * x is also x\u207b\u00b9 * y\u207b\u00b9 by group properties\n  have h3 : (y * x)\u207b\u00b9 = x\u207b\u00b9 * y\u207b\u00b9,\n  { exact mul_inv_rev y x, },\n  -- Combine the two equalities: y\u207b\u00b9 * x\u207b\u00b9 = x\u207b\u00b9 * y\u207b\u00b9\n  rw h3 at h2,\n  exact h2.symm,},\n  apply inv_abelsch,\n  exact h1,\nend\n", "K\u00f6rper", "Eindeutigkeit des inversen Elements", "import algebra.field.basic-- hide\n", "Wir werden uns nun mit K\u00f6rpern (auf englisch fields) auseinandersetzen.\nUm in einem Satz $F$ als K\u00f6rper zu definieren schreibt man zu Beginn der Voraussetzungen\n`{F : Type} [field F]`.\n\nDu kannst den Beweis mit `rintro \u27e8hxy, hxz\u27e9,` starten. Diese Taktik ist \u00e4hnlich zu\n`intro` funktioniert aber mit Beweiszielen die in ihrer Implikation ein und-Operator\nhaben.\n", "Nach dem `rintro` Befehl brauchst du nur noch `rw` schritte mit den Aussagen im Beweiszustand,\n`mul_one`, `mul_assoc`, `mul_comm` und `one_mul`.\n", "Brauchst du Hilfe?", "-- Theorem: Das Inverse in K\u00f6rpern ist eindeutig.\ntheorem eind_inv {F : Type} [field F] (x y z : F) (hx : x \u2260 0) :\n  x * y = 1 \u2227 x * z = 1 \u2192 y = z :=\nbegin\n  rintro \u27e8hxy, hxz\u27e9,\n  rw \u2190 mul_one y,\n  rw \u2190 hxz,\n  rw \u2190 mul_assoc,\n  rw mul_comm y x,\n  rw hxy,\n  rw one_mul,\nend\n", "Eindeutigkeit der Multiplikation", "import algebra.field.basic-- hide\n", "Wir werden nun den Beweis f\u00fchren, dass Multiplikation in K\u00f6rpern eindeutig ist.\nDieser Beweis wird bis auf ein paar Sonderheiten genauso funktionieren wie die\nEindeutigkeit der Verkn\u00fcpfung \u00fcber Gruppen, hier ist der Beweis zur Erinnerung:\n```\nintro h,\n  have h_inv : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * (x * z),\n  { rw h, },\n  rw [\u2190mul_assoc, \u2190mul_assoc] at h_inv,\n  rw mul_left_inv x at h_inv,\n  repeat{ rw one_mul at h_inv, },\n  exact h_inv,\n```\nStatt `mul_left_inv` hei\u00dft es in K\u00f6rpern aber `mul_inv_cancel`.\n", "-- Theorem: Die Multiplikation in K\u00f6rpern ist eindeutig.\ntheorem eind_prod {F : Type} [field F] (x y z : F) (hx : x \u2260 0) :\n  x * y = x * z \u2192 y = z :=\nbegin\n  intro h,\n  have h_inv : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * (x * z), -- Multiply both sides by x\u207b\u00b9\n  { rw h, },\n  rw [\u2190mul_assoc, \u2190mul_assoc] at h_inv, -- Simplify the left-hand and right-hand side\n  repeat {rw mul_comm x\u207b\u00b9 x at h_inv,},\n  rw mul_inv_cancel hx at h_inv,\n  repeat{ rw one_mul at h_inv, },\n  exact h_inv,\nend\n", "Wenn das Produkt $0$ ist, dann ist einer der Faktoren $0$", "import algebra.field.basic-- hide\n", "In diesem Beweis werden wir eine Fallunterscheidung durchf\u00fchren. Das tut man in \nLean mit `by cases`. Die Struktur dieser Taktik siehr wiefolgt aus:\n```\nby_cases hx : x = 0,\n{sorry,},\n{sorry,},\n```\nIn diesem Beispiel wird zwischen dem Fall $x=0$ und dem Fall $x \\neq 0$ unterschieden.\nEine weitere Besonderheit dieses Levels ist es, dass im Beweisziel ein oder-Operator\nist. In solchen f\u00e4llen kann man in verschiedenen Scopes angeben ob man gerade zeigt, dass\nder linke oder der rechte Fall gilt. In Kombination mit `by_cases` sieht das wiefolgt aus:\n```\nby_cases hx : x = 0,\n{left,\nsorry,},\n{right,\nsorry,},\n```\n", "-- Theorem: F\u00fcr $x, y \\in F$ gilt: falls $x \\cdot y = 0$ dann ist $x=0$ oder $y=0$.\ntheorem prod_null_faktor_null {F : Type} [field F] (x y : F) : x * y = 0 \u2192 x = 0 \u2228 y = 0 :=\nbegin\n  intro h,\n  by_cases hx : x = 0,\n  {left,\n  exact hx,},\n  {right,\n  have hx_inv : x\u207b\u00b9 * x = 1 := by {\n    rw mul_comm,\n    rw mul_inv_cancel,\n    exact hx,\n  },\n    have hinv_x : x\u207b\u00b9 * (x * y) = x\u207b\u00b9 * 0,\n    { rw h },\n    rw \u2190 mul_assoc at hinv_x,\n    rw hx_inv at hinv_x,\n    rw one_mul at hinv_x,\n    rw mul_zero at hinv_x,\n    exact hinv_x,\n    },\nend\n", "Falls $x^2=0$ dann $x=0$", "import algebra.field.basic-- hide\n", "import algebra.group_power.basic --hide\n", "import game.Koerper.level_3 --hide\n", "Aus der vorherigen Aufgabe kann man folgern, dass falls $x^2=0$ dann $x=0$. Du kannst\ndazu konkret den Satz, der in Level 3 bewiesen wurde verwenden. Da es in dem Satz\nF\u00e4lle gibt musst du ihn wiefolgt anwenden: `cases prod_null_faktor_null x x h with hx hx,`\nVerwende dazu `pow_two` und das Quadrat in eine Multiplikation umzuwandeln.\n", "-- Theorem: F\u00fcr $x \\in F$ gilt: falls $x^2 = 0$ dann ist $x=0$.\ntheorem quad_null_x_0 {F : Type} [field F] (x : F) : x^2 = 0 \u2192 x = 0 :=\nbegin\n  intro h,\n  rw pow_two x at h,\n  cases prod_null_faktor_null x x h with hx hx,\n  {exact hx,},\n  {exact hx,},\nend\n", "K\u00fcrzen von Br\u00fcchen", "import algebra.field.basic-- hide\n", "/- Zuletz zeigen wir, dass man Br\u00fcche k\u00fcrzen kann. In diesem Beweis reicht es, mit `rw`\nzu arbeiten. Suche dir dazu aus der linken Spalte die richtigen S\u00e4tze aus.\n-/\n-- Theorem: F\u00fcr $x, y \\in F$ mit $y \\neq 0$ gilt: $\\frac{x \\cdot y}{y} = x$.\ntheorem kuerzen_brueche {F : Type} [field F] (x y : F) (hy : y \u2260 0) : x * y / y = x :=\nbegin\n  rw div_eq_mul_inv,\n  rw mul_assoc,\n  rw mul_inv_cancel hy,\n  rw mul_one,\nend\n"]]}